#include <stdio.h>
#include <stdint.h>

typedef struct _no{
    char* val;
    struct _no *ant;
    struct _no *prox;
} No;

typedef struct _lista{
    No *inicio;
    No *fim;
    size_t tam;
} Lista;

size_t m_strlen(const char *str) {
    size_t comp = 0;

    // Percorre a string até encontrar o caractere nulo '\0'
    while (*str != '\0') {
        comp++;
        str++;
    }

    return comp;
}

char* m_strcpy(char *destino, const char *origem) {
    char *ptr = destino; // Guarda o ponteiro inicial do destino

    // Copia cada caractere da origem para o destino até encontrar o caractere nulo '\0'
    while (*origem != '\0') {
        *destino = *origem;
        destino++;
        origem++;
    }

    // Adiciona o caractere nulo de término no final da string destino
    *destino = '\0';

    return ptr; // Retorna o ponteiro inicial do destino
}

int m_strcmp(const char *str1, const char *str2) {
    // Percorre os caracteres das duas strings enquanto são iguais
    while (*str1 && *str2 && *str1 == *str2) {
        str1++;
        str2++;
    }

    // Retorna a diferença entre os caracteres encontrados ou 0 se as strings são iguais
    return (unsigned char)*str1 - (unsigned char)*str2;
}


No *cria_no(char *nome){
    No *no_criado = (No*) calloc(1, sizeof(No));
    //no_criado->val = (char*) malloc(m_strlen(nome) + 1);
    //m_strcpy(no_criado->val, nome);
    no_criado->val = nome;
    no_criado->ant = no_criado;
    no_criado->prox = no_criado;

    return no_criado;
}

Lista *cria_lista(){
    Lista *L = (Lista*) calloc(1, sizeof(Lista));
    L->inicio = NULL;
    L->fim = NULL;
    L->tam = 0;

    return L;
}

int lista_vazia(const Lista *L){
    return (L->tam == 0);
}

void adicionar_no(Lista *L, char *val){
    No *no = cria_no(val);

    if((lista_vazia(L))){
        L->inicio = no;
        L->fim = no;
    }else{
        L->fim->prox = no;
        no->ant = L->fim;
        L->fim = no;

        L->inicio->ant = no;
        no->prox = L->inicio;
    }

    L->tam++;
}

void mostrar(const Lista *L, char *nome, FILE* output){
    if(lista_vazia(L)){
        printf("L -> NULL");

    }else{
        No *p = L->inicio;

        while(m_strcmp(p->val, nome) != 0){
            p = p->prox;
        }

        No *ant = p->ant;
        No *prox = p->prox;

        fprintf(output, "[ OK  ] %s -> %s -> %s\n", ant->val, p->val, prox->val);
    }
}


int contem_nome(Lista *L, const char *nome){
    if (lista_vazia(L)) {
        return 0;
    }
    No *p = L->inicio;
    do{
        if (m_strcmp(p->val, nome) == 0) {
            return 1; // Nome encontrado
        }
        p = p->prox;
    } while (p != L->inicio);
    return 0; // Nome n�o encontrado
}

void remove_nome(Lista *L, char *nome){
    No *p = L->inicio;
    while(m_strcmp(p->val, nome) != 0){
        p = p->prox;
    }

    if (L->tam == 1) {
            // Único nó na lista
            L->inicio = NULL;
            L->fim = NULL;
        } else {
            // Nó está no meio ou nas extremidades
            No *ant = p->ant;
            ant->prox = p->prox;

            No *prox = p->prox;
            prox->ant = p->ant;

            if (p == L->inicio) {
                L->inicio = p->prox;
            }
            if (p == L->fim) {
                L->fim = p->ant;
            }
        }

        free(p->val);
        free(p);
        L->tam--;
}

void processa_linha(char* linha, Lista* L, FILE* output) {
    char comando[10];
    char nome[100];

    // Remove o caractere de nova linha, se presente
    //linha[strcspn(linha, "\n")] = '\0';

    // Usa sscanf para ler o comando e o nome
    if (sscanf(linha, "%9s %[^\n]", comando, nome) == 2) {
        if (m_strcmp(comando, "ADD") == 0) {
            if(contem_nome(L, nome)){
                fprintf(output, "[ERROR] %s %s\n", comando, nome);
            }else{
                adicionar_no(L, nome);
                fprintf(output, "[ OK  ] %s %s\n", comando, nome);
            }
        } else if (m_strcmp(comando, "REMOVE") == 0) {
            if(contem_nome(L, nome)){
                remove_nome(L, nome);
                fprintf(output, "[ OK  ] %s %s\n", comando, nome);
            }else{
                fprintf(output, "[ERROR] %s %s\n", comando, nome);
            }
        } else if (m_strcmp(comando, "SHOW") == 0) {
            if(contem_nome(L, nome)){
                mostrar(L, nome, output);
            }else{
                fprintf(output, "[ERROR] ?<-%s->?\n", nome);
            }
        }
    } else {
        fprintf(output, "[ERROR]\n");
    }
}

int main(int argc, char* argv[]) {
    Lista *L = cria_lista();

	// Exibindo a quantidade de argumentos
	printf("Quantidade de argumentos (argc): %i\n", argc);
	// Iterando sobre o(s) argumento(s) do programa
	for(uint32_t i = 0; i < argc; i++) {
		// Mostrando o argumento i
		printf("Argumento %i (argv[%i]): %s\n", i, i, argv[i]);
	}

	// Abrindo os arquivos com as permissões corretas
	FILE* input = fopen(argv[1], "r");
	FILE* output = fopen(argv[2], "w");

	 /*if (input == NULL) {
        perror("Erro ao abrir o arquivo de sa�da");
        fclose(input);
        return 1;
    }*/

    char l[100];
    int i = 1;
    while (!feof(input)) {
        fgets(l, 100, input);
        processa_linha(l, L, output);
        i++;
    }

	// Fechando os arquivos
	fclose(input);
	fclose(output);
	// Finalizando programa
	return 0;
}
